---
title: TypeScript
date: 2022-08-26 10:24:59
permalink: /pages/5a3e15/
categories:
  - 前端
  - 前端基础笔记
tags:
  - 

---

# TypeScript 

## 基础概念



### 静态类型检查（Static type-checking）

如下段代码 ， 定义一个string类型变量，把它当做函数调用， 如果是js，那么在保存文件重新运行代码时，才会抛出错误。

理想情况下，我们应该有一个工具可以帮助我们，在代码运行之前就找到错误。这就是静态类型检查器比如 TypeScript 做的事情。**静态类型系统**（Static types systems）描述了值应有的结构和行为。一个像 TypeScript 的类型检查器会利用这个信息，并且在可能会出错的时候告诉我们：

```js
const message = "hello!";
 
message();

// This expression is not callable.
// Type 'String' has no call signatures.

```

### 非异常失败（Non-exception）

JavaScript会告诉我们运行时的错误 运行时错误，就是 JavaScript 会在运行时告诉我们它认为的一些没有意义的事情。这些事情之所以会出现，是因为 [ECMAScript 规范 (opens new window)](https://tc39.github.io/ecma262/)已经明确的声明了这些异常时的行为。



* 比如在读取一个对象中不存在的属性时，js并不会报错，而是返回undefined

  ```js
  const user = {
    name: "Daniel",
    age: 26,
  };
  user.location; // returns undefined
  
  ```

  而在ts中 是这样表现得

  ```ts
  const user = {
    name: "Daniel",
    age: 26,
  };
   
  user.location;
  // Property 'location' does not exist on type '{ name: string; age: number; }'.
  
  ```

* Ts可以捕获很多合理的错误 如：

  * 拼写错误

    ```tsx
    const announcement = "Hello World!";
     
    // How quickly can you spot the typos?
    announcement.toLocaleLowercase();
    announcement.toLocalLowerCase();
     
    // We probably meant to write this...
    announcement.toLocaleLowerCase();
    
    ```

  * 定义函数未被调用

    ```js
    function flipCoin() {
      // Meant to be Math.random()
      return Math.random < 0.5;
    // Operator '<' cannot be applied to types '() => number' and 'number'.
    }
    
    ```

  * 基本逻辑错误

    ```js
    const value = Math.random() < 0.5 ? "a" : "b";
    if (value !== "a") {
      // ...
    } else if (value === "b") {
      // This condition will always return 'false' since the types '"a"' and '"b"' have no overlap.
      // Oops, unreachable
    }
    
    ```

    

### 类型工具 

​		全局安装ts `npm install typescript -g`  类型检查器因为有类型信息，可以检查比如说是否正确获取了一个变量的属性。也正是因为有这个信息，它也可以在你输入的时候，列出你可能想要使用的属性。

### `tsc` TypeScript 编译器（tsc，the TypeScript compiler）

tsc的指令：

* `tsc init` : 生成tsconfig.json 配置文件
* `tsc --watch ` : 实时编译
* `tsc --noEmitOnError hello.ts` :  当存在ts报错时 不更新js

### 显式类型

定义显式类型

```tsx
function greet(person: string, date: Date) {
  console.log(`Hello ${person}, today is ${date.toDateString()}!`);
}

```

我们所做的就是给 `person` 和 `date` 添加了**类型注解（type annotations）**，描述 `greet` 函数可以支持传入什么样的值。你可以如此理解这个**签名 (signature)**： `greet` 支持传入一个 `string` 类型的 `person` 和一个 `Date` 类型的 `date` 

### 类型抹除

类型注解并不是 JavaScript 的一部分。所以并没有任何浏览器或者运行环境可以直接运行 TypeScript 代码。 

所以在生成的js文件中我们的类型注解就全部被抹除了。

```js
"use strict";
function greet(person, date) {
    console.log("Hello " + person + ", today is " + date.toDateString() + "!");
}
greet("Maddison", new Date());

```

###  降级（Downleveling）

Ts再经过tsc的编译后生成了了

```js
"Hello " + person + ", today is " + date.toDateString() + "!";
```

是因为模板字符串是 ECMAScript2015（也被叫做 ECMAScript 6 ,ES2015, ES6 等）里的功能，TypeScript 可将新版本的代码编译为老版本的代码，比如 ECMAScript3 或者 ECMAScript5 。这个将高版本的 ECMAScript 语法转为低版本的过程就叫做**降级（downleveling）** 。

Ts 默认转换为`ES3` ，通过tsconfig target选项可以进行配置 或者用命令行配置target `tsc --target es2015 hello.ts`

### 严格模式

TypeScript 有几个严格模式设置的开关。

### `noImplicitAny`

用来检验any

### `strictNullChecks`

默认情况下，像 `null` 和 `undefined` 这样的值可以赋值给其他的类型。可以让我们更方便的写一些代码。但是忘记处理 `null` 和 `undefined` 也导致了不少的 bug

## TS常见类型

## 

## 

### 原始类型: `string`，`number` 和 `boolean`

### 数组（Array）

定义一个类似`[1,2,3]` 的数组 需要用到语法 `number[]`  这个语法可以适用于任何类型 比如 `string[]` 还有一种写法是泛型写法：`Array<number>`

```js
let arr: number[] = [1,2,3]
let arr2: Array<number> = [1,2,3]
```

### Any

不希望一个值导致类型检查错误的时候，就可以设置为 `any` 

### 类型注释

当你使用 `const`、`var` 或 `let` 声明一个变量时，你可以选择性的添加一个类型注解，显式指定变量的类型：

```js
let myName: string = "Alice";
```

TypeScript 大多数情况会自动推断类型。



### 函数

函数是 JavaScript 传递数据的主要方法。TypeScript 允许你指定函数的输入值和输出值的类型。

#### 参数类型注解（Parameter Type Annotations）

当你声明一个函数的时候，你可以在每个参数后面添加一个类型注解，声明函数可以接受什么类型的参数。参数类型注解跟在参数名字后面：

```js
// Parameter type annotation
function greet(name: string) {
  console.log("Hello, " + name.toUpperCase() + "!!");
}
```

如果入参没有指定类型，会隐式推断为any

#### 返回值类型注解（Return Type Annotations）

返回值的类型注解跟在参数列表后面

跟变量类型注解一样，你也不需要总是添加返回值类型注解，TypeScript 会基于它的 `return` 语句推断函数的返回类型。

```js
function getFavoriteNumber(): number {
  return 26;
}

```

#### 匿名函数

当 TypeScript 知道一个匿名函数将被怎样调用的时候，匿名函数的参数会被自动的指定类型。

### 对象类型

```js
// The parameter's type annotation is an object type
function printCoord(pt: { x: number; y: number }) {
  console.log("The coordinate's x value is " + pt.x);
  console.log("The coordinate's y value is " + pt.y);
}
printCoord({ x: 3, y: 7 });

```



对象类型可以指定一些甚至所有的属性为可选的，你只需要在属性名后添加一个 `?`



### 联合类型

#### 定义一个联合类型（Defining a Union Type）

第一种组合类型的方式是使用联合类型，一个联合类型是由两个或者更多类型组成的类型，表示值可能是这些类型中的任意一个。这其中每个类型都是联合类型的**成员（members）**。

```tsx
function printId(id: number | string) {
  console.log("Your ID is: " + id);
}
// OK
printId(101);
// OK
printId("202");
// Error
printId({ myID: 22342 });
```

TypeScript 会要求你做的事情，必须对每个联合的成员都是有效的 

用代码收窄联合类型，就像你在 JavaScript 没有类型注解那样使用。当 TypeScript 可以根据代码的结构推断出一个更加具体的类型时，类型收窄就会出现。 **实际上就是对类型进行判断 并进行不同的操作**

```js
function welcomePeople(x: string[] | string) {
  if (Array.isArray(x)) {
    // Here: 'x' is 'string[]'
    console.log("Hello, " + x.join(" and "));
  } else {
    // Here: 'x' is 'string'
    console.log("Welcome lone traveler " + x);
  }
}

```

如果联合类型里的每个成员都有一个属性，举个例子，数组和字符串都有 `slice` 方法，你就可以直接使用这个属性，而不用做类型收窄。

### 类型别名（Type Aliases）

在类型注解里直接使用对象类型和联合类型，这很方便，但有的时候，一个类型会被使用多次，此时我们更希望通过一个单独的名字来引用它。

类型别名，顾名思义，一个可以指代任意类型的名字。

```typescript
type Point = {x:number; y:number;}
function getPoint(po:Point){
	return `x轴${po.x},y轴${po.y}`
}
getPoint({x:1,y:2})
```



### 接口

接口声明（interface declaration）是命名对象类型的另一种方式：

```typescript
interface Point {
  x: number;
  y: number;
}
 
function printCoord(pt: Point) {
  console.log("The coordinate's x value is " + pt.x);
  console.log("The coordinate's y value is " + pt.y);
}
 
printCoord({ x: 100, y: 100 });

```

TypeScript 只关心传递给 `printCoord` 的值的结构（structure）——关心值是否有期望的属性。正是这种只关心类型的结构和能力的特性，我们才认为 TypeScript 是一个结构化（structurally）的类型系统。

#### 类型别名和接口的不同

类型别名和接口非常相似，大部分时候，你可以任意选择使用。接口的几乎所有特性都可以在 `type` 中使用，两者最关键的差别在于类型别名本身无法添加新的属性，而**接口是可以扩展**的。

```typescript
interface Animal {
	name:string
}
// 接口通过继承扩展
interface Bear extends Animal {
  honey:Boolean
}
const littleBear: Bear{
  name: 'xiaoxiong',
  honey: true
}

// 别名通过交集拓展类型
type Animal = {
	name:string
}
type Bear=  Animal & {
  honey:true
}
const bigBear:Bear = {
  name:'大熊',
  honey:false
}

```

