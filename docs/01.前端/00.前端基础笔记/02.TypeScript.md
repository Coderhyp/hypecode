---
title: TypeScript
date: 2022-08-26 10:24:59
permalink: /pages/5a3e15/
categories:
  - 前端
  - 前端基础笔记
tags:
  - 
---

# TypeScript 

## 基础概念



### 静态类型检查（Static type-checking）

如下段代码 ， 定义一个string类型变量，把它当做函数调用， 如果是js，那么在保存文件重新运行代码时，才会抛出错误。

理想情况下，我们应该有一个工具可以帮助我们，在代码运行之前就找到错误。这就是静态类型检查器比如 TypeScript 做的事情。**静态类型系统**（Static types systems）描述了值应有的结构和行为。一个像 TypeScript 的类型检查器会利用这个信息，并且在可能会出错的时候告诉我们：

```js
const message = "hello!";
 
message();

// This expression is not callable.
// Type 'String' has no call signatures.

```

### 非异常失败（Non-exception）

JavaScript会告诉我们运行时的错误 运行时错误，就是 JavaScript 会在运行时告诉我们它认为的一些没有意义的事情。这些事情之所以会出现，是因为 [ECMAScript 规范 (opens new window)](https://tc39.github.io/ecma262/)已经明确的声明了这些异常时的行为。



* 比如在读取一个对象中不存在的属性时，js并不会报错，而是返回undefined

  ```js
  const user = {
    name: "Daniel",
    age: 26,
  };
  user.location; // returns undefined
  
  ```

  而在ts中 是这样表现得

  ```ts
  const user = {
    name: "Daniel",
    age: 26,
  };
   
  user.location;
  // Property 'location' does not exist on type '{ name: string; age: number; }'.
  
  ```

* Ts可以捕获很多合理的错误 如：

  * 拼写错误

    ```tsx
    const announcement = "Hello World!";
     
    // How quickly can you spot the typos?
    announcement.toLocaleLowercase();
    announcement.toLocalLowerCase();
     
    // We probably meant to write this...
    announcement.toLocaleLowerCase();
    
    ```

  * 定义函数未被调用

    ```js
    function flipCoin() {
      // Meant to be Math.random()
      return Math.random < 0.5;
    // Operator '<' cannot be applied to types '() => number' and 'number'.
    }
    
    ```

  * 基本逻辑错误

    ```js
    const value = Math.random() < 0.5 ? "a" : "b";
    if (value !== "a") {
      // ...
    } else if (value === "b") {
      // This condition will always return 'false' since the types '"a"' and '"b"' have no overlap.
      // Oops, unreachable
    }
    
    ```

    

### 类型工具 

​		全局安装ts `npm install typescript -g`  类型检查器因为有类型信息，可以检查比如说是否正确获取了一个变量的属性。也正是因为有这个信息，它也可以在你输入的时候，列出你可能想要使用的属性。

### `tsc` TypeScript 编译器（tsc，the TypeScript compiler）

tsc的指令：

* `tsc init` : 生成tsconfig.json 配置文件
* `tsc --watch ` : 实时编译
* `tsc --noEmitOnError hello.ts` :  当存在ts报错时 不更新js

### 显式类型

定义显式类型

```tsx
function greet(person: string, date: Date) {
  console.log(`Hello ${person}, today is ${date.toDateString()}!`);
}

```

我们所做的就是给 `person` 和 `date` 添加了**类型注解（type annotations）**，描述 `greet` 函数可以支持传入什么样的值。你可以如此理解这个**签名 (signature)**： `greet` 支持传入一个 `string` 类型的 `person` 和一个 `Date` 类型的 `date` 

### 类型抹除

类型注解并不是 JavaScript 的一部分。所以并没有任何浏览器或者运行环境可以直接运行 TypeScript 代码。 

所以在生成的js文件中我们的类型注解就全部被抹除了。

```js
"use strict";
function greet(person, date) {
    console.log("Hello " + person + ", today is " + date.toDateString() + "!");
}
greet("Maddison", new Date());

```

###  降级（Downleveling）

Ts再经过tsc的编译后生成了了

```js
"Hello " + person + ", today is " + date.toDateString() + "!";
```

是因为模板字符串是 ECMAScript2015（也被叫做 ECMAScript 6 ,ES2015, ES6 等）里的功能，TypeScript 可将新版本的代码编译为老版本的代码，比如 ECMAScript3 或者 ECMAScript5 。这个将高版本的 ECMAScript 语法转为低版本的过程就叫做**降级（downleveling）** 。

Ts 默认转换为`ES3` ，通过tsconfig target选项可以进行配置 或者用命令行配置target `tsc --target es2015 hello.ts`

### 严格模式

TypeScript 有几个严格模式设置的开关。

## `noImplicitAny`

用来检验any

## `strictNullChecks`

默认情况下，像 `null` 和 `undefined` 这样的值可以赋值给其他的类型。可以让我们更方便的写一些代码。但是忘记处理 `null` 和 `undefined` 也导致了不少的 bug

## TS常见类型
